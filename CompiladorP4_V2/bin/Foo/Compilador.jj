/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */

options
{
  static = true;
  ignore_case = true;
}

PARSER_BEGIN(Compilador)
package Foo;
import Foo.Tabla_Simbolos;
import Foo.Simbolo.Tipo_simbolo;
import Foo.Simbolo.Tipo_variable;
import Foo.Simbolo.Clase_parametro;
import Foo.SimboloNoEncontradoException;
import Foo.TipoOperador.Tipo_Operador_Aditivo;
import Foo.TipoOperador.Tipo_Operador_Multiplicativo;
import Foo.TipoOperador.Tipo_Operador_Relacional;
import java.io.File;
import java.io.IOException;
import java.util.LinkedList;

public class Compilador
{
  // IniCio del nivel de declaraciones anidadas
  public static int nivel = 0;

  // Variable de direccion por defecto a 0
  public static long dir = 0;

  public static Tabla_Simbolos tabla = new Tabla_Simbolos();

  public static void main(String args []) throws ParseException
  {
    /* nombre del fichero */
    String nombreArchivo;
    String path = "C:\\Users\\Gord\\Desktop\\programas\\";
    if (args [0].equals("-v"))
    {
      System.out.println("Compilacion en modo verbose");
      nombreArchivo = args [1];
    }
    else
    {
      System.out.println("Compilacion sin modo verbose");
      nombreArchivo = args [0];
    }
    /* Completar la ruta del path */
    path += nombreArchivo;
    System.out.println("LEYENDO FICHERO " + nombreArchivo + "\n");
    try
    {
      /* Crear el parser con respecto al fichero */
      Compilador parser = new Compilador(new java.io.FileInputStream(path));
      // Inicializacion de la tabla de simbolos
      tabla.inicializar_tabla();
      int res = Compilador.programa();
      if (args [0].equals("-v"))
      {
        /* Mostrar total de tokens */
        TablaHash.mostrarTokensNormales();
        /* Mostrar total de identificadores */
        TablaHash.mostrarIdentificadores();
      }
      System.out.println("El fichero introducido es correcto");
    }
    catch (Exception e)
    {
      System.out.println("INCORRECTO");
      System.out.println(e.getMessage());
      Compilador.ReInit(System.in);
    }
    catch (Error e)
    {
      // Obtencion del error sintactico 
      int fila = CompiladorTokenManager.input_stream.getBeginLine();
      int columna = CompiladorTokenManager.input_stream.getBeginColumn();
      String tokenMalo = CompiladorTokenManager.input_stream.GetImage();
      ErrorLexico eL = new ErrorLexico(fila, columna, tokenMalo);
    }
  }
}

PARSER_END(Compilador)

SKIP : /* CARACTERES A IGNORAR */
{
  " "
| "\r"
| "\t"
| "\n"
| "%%" : ComentLinea
}

< ComentLinea >
SKIP :
{
  "%%" : DEFAULT
}

< ComentLinea >
MORE :
{
  < ~[ ] >
}

SPECIAL_TOKEN : /* Comentario de una linea */
{
  < SINGLE_LINE_COMMENT :
    "%" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
}

TOKEN : /* OPERADORES ARITMETICOS */
{
  < tPLUS : "+" >
  {
    TablaHash.anyadirHashTokens("tPLUS");
  }
| < tMINUS : "-" >
  {
    TablaHash.anyadirHashTokens("tMINUS");
  }
| < tMULTIPLY : "*" >
  {
    TablaHash.anyadirHashTokens("tMULTIPLY");
  }
| < tDIVIDE : "/" >
  {
    TablaHash.anyadirHashTokens("tDIVIDE");
  }
| < tMAYOR : ">" >
  {
    TablaHash.anyadirHashTokens("tMAYOR");
  }
| < tMENOR : "<" >
  {
    TablaHash.anyadirHashTokens("tMENOR");
  }
| < tIGUAL : "=" >
  {
    TablaHash.anyadirHashTokens("tIGUAL");
  }
| < tMAI : ">=" >
  {
    TablaHash.anyadirHashTokens("tMAI");
  }
| < tMEI : "<=" >
  {
    TablaHash.anyadirHashTokens("tMEI");
  }
| < tNI : "<>" >
  {
    TablaHash.anyadirHashTokens("tNI");
  }
| < tOPAS : ":=" >
  {
    TablaHash.anyadirHashTokens("tOPAS");
  }
}

TOKEN : /* OPERADORES LOGICOS */
{
  < tAND : "and" >
  {
    TablaHash.anyadirHashTokens("tAND");
  }
| < tOR : "or" >
  {
    TablaHash.anyadirHashTokens("tOR");
  }
| < tNOT : "not" >
  {
    TablaHash.anyadirHashTokens("tNOT");
  }
}

TOKEN : /* PALABRAS RESERVADAS */
{
  < tPROGRAMA : "programa" >
  {
    TablaHash.anyadirHashTokens("tPROGRAMA");
  }
| < tVAR : "var" >
  {
    TablaHash.anyadirHashTokens("tVAR");
  }
| < tPRINCIPIO : "principio" >
  {
    TablaHash.anyadirHashTokens("tPRINCIPIO");
  }
| < tFIN : "fin" >
  {
    TablaHash.anyadirHashTokens("tFIN");
  }
| < tSI : "si" >
  {
    TablaHash.anyadirHashTokens("tSI");
  }
| < tENT : "ent" >
  {
    TablaHash.anyadirHashTokens("tENT");
  }
| < tSI_NO : "si_no" >
  {
    TablaHash.anyadirHashTokens("tSI_NO");
  }
| < tFSI : "fsi" >
  {
    TablaHash.anyadirHashTokens("tFSI");
  }
| < tMQ : "mq" >
  {
    TablaHash.anyadirHashTokens("tMQ");
  }
| < tFMQ : "fmq" >
  {
    TablaHash.anyadirHashTokens("tFMQ");
  }
| < tESCRIBIR : "escribir" >
  {
    TablaHash.anyadirHashTokens("tESCRIBIR");
  }
| < tLEER : "leer" >
  {
    TablaHash.anyadirHashTokens("tLEER");
  }
| < tMOD : "mod" >
  {
    TablaHash.anyadirHashTokens("tMOD");
  }
| < tDIV : "div" >
  {
    TablaHash.anyadirHashTokens("tDIV");
  }
| < tENTERO : "entero" >
  {
    TablaHash.anyadirHashTokens("tENTERO");
  }
| < tBOOLEANO : "booleano" >
  {
    TablaHash.anyadirHashTokens("tBOOLEANO");
  }
| < tCARACTER : "caracter" >
  {
    TablaHash.anyadirHashTokens("tCARACTER");
  }
| < tTRUE : "true" >
  {
    TablaHash.anyadirHashTokens("tTRUE");
  }
| < tFALSE : "false" >
  {
    TablaHash.anyadirHashTokens("tFALSE");
  }
| < tENTACAR : "entacar" >
  {
    TablaHash.anyadirHashTokens("tENTACAR");
  }
| < tCARAENT : "caraent" >
  {
    TablaHash.anyadirHashTokens("tCARAENT");
  }
| < tACCION : "accion" >
  {
    TablaHash.anyadirHashTokens("tACCION");
  }
| < tVAL : "val" >
  {
    TablaHash.anyadirHashTokens("tVAL");
  }
| < tREF : "ref" >
  {
    TablaHash.anyadirHashTokens("tREF");
  }
}

TOKEN : /*EXPRESIONES */
{
  < #tDIGITO : [ "0"-"9" ] >	
| < #tLETRA : [ "a"-"z" ] >
| < tCONSTCHAR : ("\"") (~[ "\"" ]) ("\"") >
  {
    TablaHash.anyadirHashTokens("tCONSTCHAR");
  }
| < tCONSTCAD : ("\"") (~[ "\"" ])+ ("\"") >
  {
    TablaHash.anyadirHashTokens("tCONSTCAD");
  }
| < tCONSTANTE_NUMERICA : (< tDIGITO >)+ >
  {
    TablaHash.anyadirHashTokens("tCONSTANTE_NUMERICA");
  }
| < tIDENTIFICADOR :
    (
      < tLETRA >
    |
      (
        (
          < tLETRA >
        | "_"
        )
        (
          < tLETRA >
        | "_"
        | < tDIGITO >
        )*
        (
          < tLETRA >
        | < tDIGITO >
        )
      )
    ) >
  {
    TablaHash.anyadirHashTokens(image.toString());
    TablaHash.anyadirHashIdentificadores(image.toString());
  }
}

TOKEN : /* OPERADORES SEPARADDORES */
{
  < tPUNTYCOM : ";" >
  {
    TablaHash.anyadirHashTokens("tPUNTYCOM");
  }
| < tCOMA : "," >
  {
    TablaHash.anyadirHashTokens("tCOMA");
  }
| < tPARENTESIS_IZDA : "(" >
  {
    TablaHash.anyadirHashTokens("tPARENTESIS_IZDA");
  }
| < tPARENTESIS_DCHA : ")" >
  {
    TablaHash.anyadirHashTokens("tPARENTESIS_DCHA");
  }
}

/* Construccion del analizador sintactico */

// Regla de programa
int programa() :
{
  Token tSim, t;
  Simbolo s;
  Simbolo.Tipo_simbolo tp_Sim;
}
{
  try
  {
    // Lectura del token programa
    < tPROGRAMA > 
    // Guardado del nombre del programa
    t = < tIDENTIFICADOR >
    {
      // Insertar en la tabla de simbolos el token del programa
      // no se comprueba porque es el primero
      s = tabla.introducir_programa(t.image, dir);
    }
    // Lectura del resto de datos
    < tPUNTYCOM > declaracion_variables() declaracion_acciones() bloque_sentencias() < EOF >
    {
      return 0;
    }
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
    return 1;
  }
}

// Regla de bloque_sentencias OK
void bloque_sentencias() :
{
  // Declaracion de variables
  Token t;
}
{
  try
  {
    < tPRINCIPIO > lista_sentencias() t = < tFIN >
    {
      // Ocultar los parametros del nivel actual
      tabla.ocultar_parametros(nivel);
      // Detectado el fin de un bloque de sentencias
      // Mostrar el contenido de la tabla Hash
      tabla.mostrarTabla_Simbolos();
    }
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de lista_sentencias OK EN DUDA
void lista_sentencias() :
{
}
{
  try
  {
    // El bloque de sentencias tiene mas de una 
    (sentencia())+
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de sentencia OK
void sentencia() :
{
}
{
  try
  {
    leer() < tPUNTYCOM >
  | escribir() < tPUNTYCOM >
  | asig_invoc()
  | seleccion()
  | mientras_que()
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

void asig_invoc() :
{
}
{
  try
  {
    < tIDENTIFICADOR > (asignacion()
  | invocacion_accion())
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de asignacion OK
void asignacion() :
{
}
{
  try
  {
    < tOPAS > expresion() < tPUNTYCOM >
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de lista_asignables OK
void lista_asignables() :
{
}
{
  try
  {
    identificadores()
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de leer OK
void leer() :
{
}
{
  try
  {
    < tLEER > < tPARENTESIS_IZDA > lista_asignables() < tPARENTESIS_DCHA >
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de escribir OK
void escribir() :
{
}
{
  try
  {
    < tESCRIBIR > < tPARENTESIS_IZDA > lista_escribibles() < tPARENTESIS_DCHA >
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de lista_escribibles OK
void lista_escribibles() :
{
}
{
  try
  {
    escribible() (< tCOMA > escribible()) *
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de lista_escribibles OK
void escribible() :
{
}
{
  try
  {
    < tCONSTCHAR >
  | < tCONSTCAD >
  | < tENTACAR > < tPARENTESIS_IZDA > < tCONSTANTE_NUMERICA > < tPARENTESIS_DCHA >
  | < tIDENTIFICADOR >
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de invocacion accion OK
void invocacion_accion() :
{
}
{
  try
  {
    (argumentos()) ? < tPUNTYCOM >
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

//Regla de mientras que OK
void mientras_que() :
{
}
{
  try
  {
    < tMQ > expresion() lista_sentencias() < tFMQ >
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla para los argumentos OK
void argumentos() :
{
}
{
  try
  {
    < tPARENTESIS_IZDA > (lista_expresiones()) ? < tPARENTESIS_DCHA >
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de lista de expresiones
void lista_expresiones() :
{
}
{
  try
  {
    expresion() (< tCOMA > expresion()) *
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de expresion OK
RegistroExp expresion() :
{
  // Declaracion de expresiones a analizar
  RegistroExp tpExp1, tpExp2;
  TipoOperador op;
  
  boolean ok;
  RegistroExp regResult = new RegistroExp();
}
{
  try
  {
    // Obtencion de la primera expresion
    tpExp1 = expresion_simple()
    ( op = operador_relacional()
	  // Obtencion de la segunda expresion
      tpExp2 = expresion_simple()
      {
        // Evaluacion de la expresion
        // Resultado de evaluar la expresion
        regResult = new RegistroExp();
        ok = true;

        // Evaluar el simbolo introducido
        switch(op.getOperadorRelacional()) {
          case IGUAL:
          	// El operador es una suma

          	// Evaluar primer termino de la expresion
          	if (tpExp1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 1 debe ser entero " +
          		  											"caracter, cadena o booleano");
          		  ok = false;
          	}
          	// Evaluar segundo termino de la expresion
          	if (tpExp2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 1 debe ser entero " +
          		  											"caracter, cadena o booleano");
          		  ok = false;
          	}
          	// Comprobar que todo ha ido bien y evaluar la expresion
          	if (ok) {
          	  // Verficar que los dos operandos son del mismo tipo
          	  if (tpExp1.getTipo() == tpExp2.getTipo())
          	  {
          	    	// Tipo de la nueva expresion
          	    	regResult.setTipo(Simbolo.Tipo_variable.ENTERO);

					// Extracion de los valores numericos de cada operador

					// OJO
       				int operando1 = tpExp1.getValorEnt();
       				int operando2 = tpExp2.getValorEnt();

					// Suma de los operandos numericos
       				boolean resul = operando1 == operando2;

       				// Asignacion del resultado a la expresion resultado 
          	    	regResult.setValorBool(resul);
          	  }
          	  else
          	  {
          	    // Error semantico de tipos distintos
          	    ErrorSemantico eSM = new ErrorSemantico("Los operadores son distintos");
          	  }         	    
          	}
          	break;
          	case MENOR:
          	// El operador es una suma

          	// Evaluar primer termino de la expresion
          	if ((tpExp1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpExp1.getTipo() != Simbolo.Tipo_variable.BOOLEANO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 1 debe ser entero " +
          		  											"caracter o cadena");
          		  ok = false;
          	}
          	// Evaluar segundo termino de la expresion
          	if ((tpExp2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpExp2.getTipo() != Simbolo.Tipo_variable.BOOLEANO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 1 debe ser entero " +
          		  											"caracter o cadena");
          		  ok = false;
          	}
          	// Comprobar que todo ha ido bien y evaluar la expresion
          	if (ok) {
          	  // Verficar que los dos operandos son del mismo tipo
          	  if (tpExp1.getTipo() == tpExp2.getTipo())
          	  {
          	    	// Tipo de la nueva expresion
          	    	regResult.setTipo(Simbolo.Tipo_variable.ENTERO);

					// Extracion de los valores numericos de cada operador

					// OJO
       				int operando1 = tpExp1.getValorEnt();
       				int operando2 = tpExp2.getValorEnt();

					// Suma de los operandos numericos
       				boolean resul = operando1 < operando2;

       				// Asignacion del resultado a la expresion resultado 
          	    	regResult.setValorBool(resul);
          	  }
          	  else
          	  {
          	    // Error semantico de tipos distintos
          	    ErrorSemantico eSM = new ErrorSemantico("Los operadores son distintos");
          	  }         	    
          	}
          	break;
          	case MENOR_IGUAL:
          	// El operador es una suma

          	// Evaluar primer termino de la expresion
          	if ((tpExp1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpExp1.getTipo() != Simbolo.Tipo_variable.BOOLEANO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 1 debe ser entero " +
          		  											"caracter o cadena");
          		  ok = false;
          	}
          	// Evaluar segundo termino de la expresion
          	if ((tpExp2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpExp2.getTipo() != Simbolo.Tipo_variable.BOOLEANO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 1 debe ser entero " +
          		  											"caracter o cadena");
          		  ok = false;
          	}
          	// Comprobar que todo ha ido bien y evaluar la expresion
          	if (ok) {
          	  // Verficar que los dos operandos son del mismo tipo
          	  if (tpExp1.getTipo() == tpExp2.getTipo())
          	  {
          	    	// Tipo de la nueva expresion
          	    	regResult.setTipo(Simbolo.Tipo_variable.ENTERO);

					// Extracion de los valores numericos de cada operador

					// OJO
       				int operando1 = tpExp1.getValorEnt();
       				int operando2 = tpExp2.getValorEnt();

					// Suma de los operandos numericos
       				boolean resul = operando1 == operando2;

       				// Asignacion del resultado a la expresion resultado 
          	    	regResult.setValorBool(resul);
          	  }
          	  else
          	  {
          	    // Error semantico de tipos distintos
          	    ErrorSemantico eSM = new ErrorSemantico("Los operadores son distintos");
          	  }         	    
          	}
          	break;
          	case NO_IGUAL:
          	// El operador es una suma

          	// Evaluar primer termino de la expresion
          	if (tpExp1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 1 debe ser entero " +
          		  											"caracter, cadena, booleano");
          		  ok = false;
          	}
          	// Evaluar segundo termino de la expresion
          	if (tpExp2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 1 debe ser entero " +
          		  											"caracter, cadena o booleano");
          		  ok = false;
          	}
          	// Comprobar que todo ha ido bien y evaluar la expresion
          	if (ok) {
          	  // Verficar que los dos operandos son del mismo tipo
          	  if (tpExp1.getTipo() == tpExp2.getTipo())
          	  {
          	    	// Tipo de la nueva expresion
          	    	regResult.setTipo(Simbolo.Tipo_variable.ENTERO);

					// Extracion de los valores numericos de cada operador

					// OJO
       				int operando1 = tpExp1.getValorEnt();
       				int operando2 = tpExp2.getValorEnt();

					// Suma de los operandos numericos
       				boolean resul = operando1 != operando2;

       				// Asignacion del resultado a la expresion resultado 
          	    	regResult.setValorBool(resul);
          	  }
          	  else
          	  {
          	    // Error semantico de tipos distintos
          	    ErrorSemantico eSM = new ErrorSemantico("Los operadores son distintos");
          	  }         	    
          	}
          	break;
          	case MAYOR_IGUAL:
          	// El operador es una suma

          	// Evaluar primer termino de la expresion
          	if ((tpExp1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpExp1.getTipo() != Simbolo.Tipo_variable.BOOLEANO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 1 debe ser entero " +
          		  											"caracter o cadena");
          		  ok = false;
          	}
          	// Evaluar segundo termino de la expresion
          	if ((tpExp2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpExp2.getTipo() != Simbolo.Tipo_variable.BOOLEANO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 1 debe ser entero " +
          		  											"caracter o cadena");
          		  ok = false;
          	}
          	// Comprobar que todo ha ido bien y evaluar la expresion
          	if (ok) {
          	  // Verficar que los dos operandos son del mismo tipo
          	  if (tpExp1.getTipo() == tpExp2.getTipo())
          	  {
          	    	// Tipo de la nueva expresion
          	    	regResult.setTipo(Simbolo.Tipo_variable.ENTERO);

					// Extracion de los valores numericos de cada operador

					// OJO
       				int operando1 = tpExp1.getValorEnt();
       				int operando2 = tpExp2.getValorEnt();

					// Suma de los operandos numericos
       				boolean resul = operando1 >= operando2;

       				// Asignacion del resultado a la expresion resultado 
          	    	regResult.setValorBool(resul);
          	  }
          	  else
          	  {
          	    // Error semantico de tipos distintos
          	    ErrorSemantico eSM = new ErrorSemantico("Los operadores son distintos");
          	  }         	    
          	}
          	break;
          	case MAYOR:
          	// El operador es una suma

          	// Evaluar primer termino de la expresion
          	if ((tpExp1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpExp1.getTipo() != Simbolo.Tipo_variable.BOOLEANO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 1 debe ser entero " +
          		  											"caracter o cadena");
          		  ok = false;
          	}
          	// Evaluar segundo termino de la expresion
          	if ((tpExp2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpExp2.getTipo() != Simbolo.Tipo_variable.BOOLEANO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 1 debe ser entero " +
          		  											"caracter o cadena");
          		  ok = false;
          	}
          	// Comprobar que todo ha ido bien y evaluar la expresion
          	if (ok) {
          	  // Verficar que los dos operandos son del mismo tipo
          	  if (tpExp1.getTipo() == tpExp2.getTipo())
          	  {
          	    	// Tipo de la nueva expresion
          	    	regResult.setTipo(Simbolo.Tipo_variable.ENTERO);

					// Extracion de los valores numericos de cada operador

					// OJO
       				int operando1 = tpExp1.getValorEnt();
       				int operando2 = tpExp2.getValorEnt();

					// Suma de los operandos numericos
       				boolean resul = operando1 > operando2;

       				// Asignacion del resultado a la expresion resultado 
          	    	regResult.setValorBool(resul);
          	  }
          	  else
          	  {
          	    // Error semantico de tipos distintos
          	    ErrorSemantico eSM = new ErrorSemantico("Los operadores son distintos");
          	  }         	    
          	}
          	default:
          		// No es un operador aditivo valido
          		ErrorSemantico eSM = new ErrorSemantico("El operador relacional es desconocido");
        }
        // Devolucion de la expresion
        return regResult;
      }
    ) *
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de operador_relacional OK
TipoOperador operador_relacional() :
{
  // Declaracion de variables
  TipoOperador op = new TipoOperador();
}
{
  try
  {
    < tIGUAL >
    {
      // Es el operador ==
      op.setOperadorRelacional(TipoOperador.Tipo_Operador_Relacional.IGUAL);
      return op;
    }
  | < tMENOR >
  	{
  	   // Es el operador <
  	   op.setOperadorRelacional(TipoOperador.Tipo_Operador_Relacional.MENOR);
       return op;
  	}
  | < tMEI >
  	{
  	   // Es el operador <=
  	   op.setOperadorRelacional(TipoOperador.Tipo_Operador_Relacional.MENOR_IGUAL);
       return op;
  	}
  | < tNI >
  	{
  	   // Es el operador <>
  	   op.setOperadorRelacional(TipoOperador.Tipo_Operador_Relacional.NO_IGUAL);
       return op;
  	}
  | < tMAI >
  	{
  	   // Es el operador >=
  	   op.setOperadorRelacional(TipoOperador.Tipo_Operador_Relacional.MAYOR_IGUAL);
       return op;
  	}
  | < tMAYOR >
  	{
  	   // Es el operador >
  	   op.setOperadorRelacional(TipoOperador.Tipo_Operador_Relacional.MAYOR);
       return op;
  	}
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla operador aditivo OK
TipoOperador operador_aditivo() :
{
  // Declaracion de variables
  TipoOperador op = new TipoOperador();
}
{
  try
  {
    < tPLUS >
    {
     	// El operador es una suma
     	op.setOperadorAditivo(TipoOperador.Tipo_Operador_Aditivo.SUMA);
     	return op;
    }
  | < tMINUS >
  	{
  	  	// El operaodr es una resta
  	    op.setOperadorAditivo(TipoOperador.Tipo_Operador_Aditivo.RESTA);
  	    return op;
  	}
  | < tOR >
  	{
  	  	// El operador es un OR
  	    op.setOperadorAditivo(TipoOperador.Tipo_Operador_Aditivo.OR);
  	    return op;
  	}
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// regla de expresion simple OK
RegistroExp expresion_simple() :
{
  // Declaracion de variables
  RegistroExp regTerm1, regTerm2, regResult;
  TipoOperador op;
  boolean ok;
}
{
  try
  {
    // Primer termino de la expresion
    regTerm1 = termino()
    (
      // Operador de la expresion
      op = operador_aditivo()

      // Segundo termino de la expresion
      regTerm2 = termino()
      {
        // Resultado de evaluar la expresion
        regResult = new RegistroExp();
        ok = true;

        // Evaluar el simbolo introducido
        switch(op.getOperadorAditivo()) {
          case SUMA:
          	// El operador es una suma

          	// Evaluar primer termino de la expresion
          	if ((regTerm1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (regTerm1.getTipo() != Simbolo.Tipo_variable.ENTERO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 1 debe ser entero");
          		  ok = false;
          	}
          	// Evaluar segundo termino de la expresion
          	if ((regTerm2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (regTerm2.getTipo() != Simbolo.Tipo_variable.ENTERO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 2 debe ser entero");
          		  ok = false;
          	}
          	// Comprobar que todo ha ido bien y evaluar la expresion
          	if (ok) {
          	  // Calculo de la expresion
          	  if (regTerm1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO
          	  		&& regTerm2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          	  {
          	    	// Tipo de la nueva expresion
          	    	regResult.setTipo(Simbolo.Tipo_variable.ENTERO);

					// Extracion de los valores numericos de cada operador
       				int operando1 = regTerm1.getValorEnt();
       				int operando2 = regTerm1.getValorEnt();

					// Suma de los operandos numericos
       				int resul = operando1 + operando2;

       				// Asignacion del resultado a la expresion resultado 
          	    	regResult.setValorEnt(resul);
          	  }
          	  else
          	  {
          	    // El tipo de la expresion es desconocido
          	    regResult.setTipo(Simbolo.Tipo_variable.DESCONOCIDO);
          	  }         	    
          	}
          	break;
          	case RESTA:
          	// El operador es una resta

          	// Evaluar primer termino de la expresion
          	if ((regTerm1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (regTerm1.getTipo() != Simbolo.Tipo_variable.ENTERO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 1 debe ser entero");
          		  ok = false;
          	}
          	// Evaluar segundo termino de la expresion
          	if ((regTerm2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (regTerm2.getTipo() != Simbolo.Tipo_variable.ENTERO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 2 debe ser entero");
          		  ok = false;
          	}
          	// Comprobar que todo ha ido bien y evaluar la expresion
          	if (ok) {
          	  // Calculo de la expresion
          	  if (regTerm1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO
          	  		&& regTerm2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          	  {
          	    	// Tipo de la nueva expresion
          	    	regResult.setTipo(Simbolo.Tipo_variable.ENTERO);

					// Extracion de los valores numericos de cada operador
       				int operando1 = regTerm1.getValorEnt();
       				int operando2 = regTerm1.getValorEnt();

					// Suma de los operandos numericos
       				int resul = operando1 - operando2;

       				// Asignacion del resultado a la expresion resultado 
          	    	regResult.setValorEnt(resul);
          	  }
          	  else
          	  {
          	    // El tipo de la expresion es desconocido
          	    regResult.setTipo(Simbolo.Tipo_variable.DESCONOCIDO);
          	  }         	    
          	}
          	break;
          	case OR:
          	// El operador es un OR logico

          	// Evaluar primer termino de la expresion
          	if ((regTerm1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (regTerm1.getTipo() != Simbolo.Tipo_variable.BOOLEANO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 1 debe ser booleano");
          		  ok = false;
          	}
          	// Evaluar segundo termino de la expresion
          	if ((regTerm2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (regTerm2.getTipo() != Simbolo.Tipo_variable.BOOLEANO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El operador 2 debe ser booleano");
          		  ok = false;
          	}
          	// Comprobar que todo ha ido bien y evaluar la expresion
          	if (ok) {
          	  // Calculo de la expresion
          	  if (regTerm1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO
          	  		&& regTerm2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          	  {
          	    	// Tipo de la nueva expresion
          	    	regResult.setTipo(Simbolo.Tipo_variable.BOOLEANO);

					// Extracion de los valores numericos de cada operador
       				boolean operando1 = regTerm1.isValorBool();
       				boolean operando2 = regTerm1.isValorBool();

					// Suma de los operandos numericos
       				boolean resul = operando1 | operando2;

       				// Asignacion del resultado a la expresion resultado 
          	    	regResult.setValorBool(resul);
          	  }
          	  else
          	  {
          	    // El tipo de la expresion es desconocido
          	    regResult.setTipo(Simbolo.Tipo_variable.DESCONOCIDO);
          	  }         	    
          	}
          	break;
          	default:
          		// No es un operador aditivo valido
          		ErrorSemantico eSM = new ErrorSemantico("El operador aditivo es desconocido");
        }
        return regResult;
      }
      ) *
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// LOS OPERADORES SON AND Y ESAS MIERDAS EH
// Regla de termino OK
RegistroExp termino() :
{
 
  // Declaracion de factores y expresiones
  RegistroExp tpFactor1, tpFactor2;

  // Declaracion del operador
  TipoOperador op;
  boolean ok;
}
{
  try
  {
     // Evaluacion del primer factor
     tpFactor1 = factor()
     (
       // Evaluacion del operador multiplicativo
       op = operador_multiplicativo()

       // Evaluacion del segundo factor
       tpFactor2 = factor()
       {
          // Expresion a devolver
          RegistroExp regResult = new RegistroExp();

          ok = true;

        // Evaluar el simbolo introducido
        switch(op.getOperadorMultiplicativo()) {
          case MULTIPLICACION:
          	// El operador es una suma

          	// Evaluar primer termino de la expresion
          	if ((tpFactor1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpFactor1.getTipo() != Simbolo.Tipo_variable.ENTERO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El factor 1 del producto " +
          		  											"debe ser entero");
          		  ok = false;
          	}
          	// Evaluar segundo termino de la expresion
          	if ((tpFactor2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpFactor2.getTipo() != Simbolo.Tipo_variable.ENTERO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El factor 2 del producto " +
          		  											"debe ser entero");
          		  ok = false;
          	}
          	// Comprobar que todo ha ido bien y evaluar la expresion
          	if (ok) {
          	  // Calculo de la expresion
          	  if (tpFactor1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO
          	  		&& tpFactor2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          	  {
          	    	// Tipo de la nueva expresion
          	    	regResult.setTipo(Simbolo.Tipo_variable.ENTERO);

					// Extracion de los valores numericos de cada operador
       				int operando1 = tpFactor1.getValorEnt();
       				int operando2 = tpFactor2.getValorEnt();

					// Multiplicacion de los operandos numericos
       				int resul = operando1 * operando2;

       				// Asignacion del resultado a la expresion resultado 
          	    	regResult.setValorEnt(resul);
          	  }
          	  else
          	  {
          	    // El tipo de la expresion es desconocido
          	    regResult.setTipo(Simbolo.Tipo_variable.DESCONOCIDO);
          	  }         	    
          	}
          	break;
          	case DIVISION:
          	// El operador es una resta

          	// Evaluar primer termino de la expresion
          	if ((tpFactor1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpFactor2.getTipo() != Simbolo.Tipo_variable.ENTERO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El dividendo debe ser entero");
          		  ok = false;
          	}
          	// Evaluar segundo termino de la expresion
          	if ((tpFactor1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpFactor2.getTipo() != Simbolo.Tipo_variable.ENTERO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El divisor debe ser entero");
          		  ok = false;
          	}
          	// Comprobar que todo ha ido bien y evaluar la expresion
          	if (ok) {
          	  // Calculo de la expresion
          	  if (tpFactor1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO
          	  		&& tpFactor2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          	  {
          	    	// Comprobacion de que el segundo termino no es cero
          	    	int operando2 = tpFactor2.getValorEnt();

          	    	if (operando2 != 0)
          	    	{
          	    	  // La operacion se puede efectuar
          	    	  // Tipo de la nueva expresion
	          	      regResult.setTipo(Simbolo.Tipo_variable.ENTERO);
	
					  // Extracion de los valores numericos de cada operador
	       			  int operando1 = tpFactor1.getValorEnt();
	       				
	
				      // Cocientes de los operandos
	       			  int resul = operando1 / operando2;
	
	       		      // Asignacion del resultado a la expresion resultado 
	          	      regResult.setValorEnt(resul);
          	    	}
          	    	else
          	    	{
          	    	  // Error al dividir por cero
          	    	  ErrorSemantico eSM = new ErrorSemantico("Division por cero");
          		  	  ok = false; 
          	    	}
          	  }
          	  else
          	  {
          	    // El tipo de la expresion es desconocido
          	    regResult.setTipo(Simbolo.Tipo_variable.DESCONOCIDO);
          	  }         	    
          	}
          	break;
          	case MOD:
          	// El operador es un OR logico

          	// Evaluar primer termino de la expresion
          	if ((tpFactor1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpFactor1.getTipo() != Simbolo.Tipo_variable.ENTERO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El dividendo debe ser entero");
          		  ok = false;
          	}
          	// Evaluar segundo termino de la expresion
          	if ((tpFactor2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpFactor2.getTipo() != Simbolo.Tipo_variable.ENTERO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El divisor debe ser entero");
          		  ok = false;
          	}
          	// Comprobar que todo ha ido bien y evaluar la expresion
          	if (ok) {
          	  // Calculo de la expresion
          	  if (tpFactor1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO
          	  		&& tpFactor2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          	  {
          	    	// Comprobacion de que el segundo termino no es cero
          	    	int operando2 = tpFactor2.getValorEnt();

          	    	if (operando2 != 0)
          	    	{
          	    	  // La operacion se puede efectuar
          	    	  // Tipo de la nueva expresion
	          	      regResult.setTipo(Simbolo.Tipo_variable.ENTERO);
	
					  // Extracion de los valores numericos de cada operador
	       			  int operando1 = tpFactor1.getValorEnt();
	       				
	
				      // Modulo de los operandos
	       			  int resul = operando1 % operando2;
	
	       		      // Asignacion del resultado a la expresion resultado 
	          	      regResult.setValorEnt(resul);
          	    	}
          	    	else
          	    	{
          	    	  // Error al dividir por cero
          	    	  ErrorSemantico eSM = new ErrorSemantico("Modulo por cero");
          		  	  ok = false; 
          	    	}     	    
          	  }
          	  else
          	  {
          	    // El tipo de la expresion es desconocido
          	    regResult.setTipo(Simbolo.Tipo_variable.DESCONOCIDO);
          	  }         	    
          	}
          	break;
          	case AND:
          	// El operador es una AND logica

          	// Evaluar primer termino de la expresion
          	if ((tpFactor1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpFactor1.getTipo() != Simbolo.Tipo_variable.BOOLEANO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El factor 1 debe ser booleano");
          		  ok = false;
          	}
          	// Evaluar segundo termino de la expresion
          	if ((tpFactor2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          		&& (tpFactor2.getTipo() != Simbolo.Tipo_variable.BOOLEANO))
          	{
          		  ErrorSemantico eSM = new ErrorSemantico("El factor 2 debe ser booleano");
          		  ok = false;
          	}
          	// Comprobar que todo ha ido bien y evaluar la expresion
          	if (ok) {
          	  // Calculo de la expresion
          	  if (tpFactor1.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO
          	  		&& tpFactor2.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)
          	  {          	  
          	    	// Tipo de la nueva expresion
          	    	regResult.setTipo(Simbolo.Tipo_variable.ENTERO);

					// Extracion de los valores numericos de cada operador
       				boolean operando1 = tpFactor1.isValorBool();
       				boolean operando2 = tpFactor2.isValorBool();

					// Operacion logica AND de los operandos
       				boolean resul = operando1 & operando2;

       				// Asignacion del resultado a la expresion resultado 
          	    	regResult.setValorBool(resul);
          	  }
          	  else
          	  {
          	    // El tipo de la expresion es desconocido
          	    regResult.setTipo(Simbolo.Tipo_variable.DESCONOCIDO);
          	  }         	    
          	}
          	break;
          	default:
          		// No es un operador aditivo valido
          		ErrorSemantico eSM = new ErrorSemantico("El operador multiplicativo" +
          												" es desconocido");
        }
        // Devolucion de la expresion
        return regResult;
       }
      ) *
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de operador multiplicativo OK
TipoOperador operador_multiplicativo() :
{
  // Declaracion de variables
  TipoOperador op = new TipoOperador();
}
{
  try
  {
    < tMULTIPLY >
    {
      // El operador es una multiplicacion
      op.setOperadorMultiplicativo(TipoOperador.Tipo_Operador_Multiplicativo.MULTIPLICACION);
      return op;
    }
  | < tDIVIDE >
  	{
  	  // El operador es un cociente (opcion 1)
      op.setOperadorMultiplicativo(TipoOperador.Tipo_Operador_Multiplicativo.DIVISION);
      return op;
  	}
  | < tDIV >
  	{
  	  // El operador es un cociente (opcion 2)
      op.setOperadorMultiplicativo(TipoOperador.Tipo_Operador_Multiplicativo.DIVISION);
      return op;
  	}
  | < tMOD >
  	{
  	  // El operador es un modulo o residuo
      op.setOperadorMultiplicativo(TipoOperador.Tipo_Operador_Multiplicativo.MOD);
      return op;
  	}
  | < tAND >
  	{
  	  // El operador es una AND logica
      op.setOperadorMultiplicativo(TipoOperador.Tipo_Operador_Multiplicativo.AND);
      return op;
  	}
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de factor OK
RegistroExp factor() :
{
   // Declaracion de factores y expresiones
   RegistroExp tpFactor, tpExp;
   RegistroExp result = new RegistroExp();

	// Token a procesar
   Token t;
}
{
  try
  {
    < tNOT > tpFactor = factor()
    {
      // Comprobacion de si es o no booleano
      if ((tpFactor.getTipo() != Simbolo.Tipo_variable.BOOLEANO)
          && (tpFactor.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)) 
      {
        // Comprobacion de si es booleano o no 
        ErrorSemantico eSM = new ErrorSemantico("Tipo incompatible. Se esperaba BOOLEANO");
      }
      // Devuelve el tipo de factor
      return tpFactor;
    }
  | < tMINUS > tpFactor = factor()
    {
      // Comprobacion de si es o no booleano
      if ((tpFactor.getTipo() != Simbolo.Tipo_variable.ENTERO)
          && (tpFactor.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO)) 
      {
        // Comprobacion de si es booleano o no 
        ErrorSemantico eSM = new ErrorSemantico("Tipo incompatible. Se esperaba ENTERO");
      }
      // Devuelve el tipo de factor
      return tpFactor;
    }
  | < tPARENTESIS_IZDA > tpExp = expresion() < tPARENTESIS_DCHA >
  	{
  	  // Devuelve la expresiom normal
  	  return tpExp;
  	}
  | < tENTACAR > < tPARENTESIS_IZDA > tpExp = expresion() < tPARENTESIS_DCHA >
  	{
  	  // Comprobacion de si es entera la expresion
  	  if ((tpExp.getTipo() != Simbolo.Tipo_variable.ENTERO)
  	  	  && (tpExp.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO))
  	  {
  	    // Comprobacion de si es booleano o no 
        ErrorSemantico eSM = new ErrorSemantico("La expresion no se puede convertir " +
        										" en un caracter valido");
  	  }
  	  else
  	  {
  	    // Es un entero y se comprueba que no hay desbordamiento
  	    int valor = tpExp.getValorEnt();
  	    
  	    // Error de desbordamiento
  	    ErrorSemantico eSM = new ErrorSemantico();
  	    
  	    if (!eSM.hayDesbordamiento(valor))
  	    {
  	      // Comprobacion de si es booleano o no 
          eSM = new ErrorSemantico("Desbordamiento detectado");
  	  	}
  	  }
  	  return tpExp;
  	}
  | < tCARAENT > < tPARENTESIS_IZDA > tpExp = expresion() < tPARENTESIS_DCHA >
  	{
  	  if ((tpExp.getTipo() != Simbolo.Tipo_variable.CHAR)
  	  		&& (tpExp.getTipo() != Simbolo.Tipo_variable.DESCONOCIDO))
  	  {
  	  	// Comprobacion de si es o no caracter
        ErrorSemantico eSM = new ErrorSemantico("Tipo incompatible. Se esperaba CARACTER");
  	  }
  	  return tpExp;
  	}
  | < tIDENTIFICADOR >
  	{
  	  // AQUI QUE HAY QUE HACER
  	}
  | t = < tCONSTANTE_NUMERICA >
  	{
  	  // Obtener el valor del token y pasarlo a entero para guardarlo
  	  int valor = Integer.parseInt(t.image);
  	  result.setValorEnt(valor);

	  // Tipo de la variable entero
  	  result.setTipo(Simbolo.Tipo_variable.ENTERO);

	  // Devolucion del resultado
  	  return result;
  	}
  | t = < tCONSTCHAR >
  	{
  	   // Guardar el contenido de la cadena
  	  result.setValorString(t.image);
  	  // Char
  	  result.setTipo(Simbolo.Tipo_variable.CHAR);
  	  // Devolucion del resultado
  	  return result;
  	}
  | t = < tCONSTCAD >
  	{
  	  // Guardar el contenido de la cadena
  	  result.setValorString(t.image);
  	  // Tipo cadena de caracteres
  	  result.setTipo(Simbolo.Tipo_variable.CADENA);
  	  // Devolucion del resultado
  	  return result;
  	}
  | < tTRUE >
  	{
  	  // Guardar el contenido de la cadena
  	  result.setValorBool(true);
  	  // Tipo cadena de caracteres
  	  result.setTipo(Simbolo.Tipo_variable.BOOLEANO);
  	  // Devolucion del resultado
  	  return result;
  	}
  | < tFALSE >
  	{
  	  // Guardar el contenido de la cadena
  	  result.setValorBool(false);
  	  // Tipo cadena de caracteres
  	  result.setTipo(Simbolo.Tipo_variable.BOOLEANO);
  	  // Devolucion del resultado
  	  return result;
  	}
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de seelccion OK
void seleccion() :
{
}
{
  try
  {
    < tSI > expresion() < tENT > lista_sentencias() (< tSI_NO > lista_sentencias()) ? < tFSI >
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de declaracion_acciones OK
void declaracion_acciones() :
{
}
{
  try
  {
    (declaracion_accion()) *
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de declaracion_Accion OK
void declaracion_accion() :
{
}
{
  try
  {
    cabecera_accion() < tPUNTYCOM > declaracion_variables() declaracion_acciones() bloque_sentencias()
    {
      // Eliminacion de variables
      tabla.eliminar_variables(nivel);
      // Eliminar las acciones
      tabla.eliminar_acciones(nivel);
      // Eliminar los parametros ocultos
      tabla.eliminar_parametros_ocultos(nivel + 1);
      // Decrementar el nivel porque se cierra un bloque       
      nivel--;
    }
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de cabecera_accion OK
void cabecera_accion() :
{
  Token tId;
  Simbolo s = null;
  Simbolo.Tipo_simbolo tp_Sim;
  boolean ok = false;
  // Lista de parametros de la accion
  LinkedList < LinkedList < Simbolo > > listaDeParametros = new LinkedList < LinkedList < Simbolo > > ();
}
{
  try
  {
    // Apilar la nueva definicion de accion si no existe   
    < tACCION > 
    tId = < tIDENTIFICADOR >
    {
      // Insertar en la tabla de simbolos el nuevo identificador
      try
      {
        s = tabla.introducir_accion(tId.image, nivel, dir);
        ok = true;	
      }
      catch (AccionRepetidaException aRepExcep)
      {
        // El simbolo ya existe en la tabla de simbolos
        aRepExcep.accionRepetidaExcepcion(tId.image);
      }
      // Incrementar el nivel actual
      nivel++;
    }
    // Procesamiento de los parametros
    listaDeParametros = parametros_formales()
    {
      // Se ha efectuado con exito
      if (ok)
      {
        for (int i = 0; i < listaDeParametros.size(); i++)
        {
          // Añadir la lista de parametros al simbolo
          s.anyadirParametrosAccion(listaDeParametros.get(i));
        }
      }
    }
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de parametros formales OK
LinkedList < LinkedList < Simbolo > > parametros_formales() :
{
  // Lista global de listas de identificadores
  LinkedList < LinkedList < Simbolo > > parametros = new LinkedList < LinkedList < Simbolo > > ();
}
{
  try
  {
    (parametros = lista_parametros()
    {
      // Guardado de la lista de parametros procesada
      tabla.asignarListaParametros(parametros);
    }
    ) ?
    // Devolucion de todas las listas procesadas
    {
      return tabla.getListasParametros();
    }
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla para lista_parametros OK
LinkedList < LinkedList < Simbolo > > lista_parametros() :
{
  // Lista global de listas de identificadores
  LinkedList < LinkedList < Simbolo > > listaGlobal = new LinkedList < LinkedList < Simbolo > > ();
  // Lista de identificadores
  LinkedList < Simbolo > lista = new LinkedList < Simbolo > ();
}
{
  try
  {
    < tPARENTESIS_IZDA > lista = parametros()
    {
      // Vaciar lista de identificadores de parametros para evitar su resinsercion
      listaGlobal.add(lista);		
    }
    (< tPUNTYCOM > lista = parametros()
    {
      listaGlobal.add(lista);
    }
    ) * < tPARENTESIS_DCHA >
    {
      return listaGlobal;
    }
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de parametros OK
LinkedList < Simbolo > parametros() :
{
  // Declaracion de variables
  // Simbolo a guardar en la tabla de simbolos
  Simbolo s;
  // Clase de parametro y tipo de variable del simbolo a introducir
  Simbolo.Clase_parametro cl_Param;
  Simbolo.Tipo_variable tipo_Var;
  // Lista de simbolos leidos a almacenar en la tabla de simbolos
  LinkedList < Simbolo > lista = new LinkedList < Simbolo > ();
  // Lista de identificadores procesados
  LinkedList < String > listaIdentificadores = new LinkedList < String > ();
}
{
  try
  {
    // Lectura del tipo de clase y del tipo de parametro
    cl_Param = clase_parametros() 
    tipo_Var = tipos_variables() 
    listaIdentificadores = identificadores()
    {
      // Tamaño de la lista de identificadores
      int dimension = listaIdentificadores.size();
      // Identificador del simbolo a procesar
      String identificadorActual;
      // Bucle de recorrido de la lista de identificadores
      for (int i = 0; i < dimension; i++)
      {
        // Obtener identificador actual
        identificadorActual = listaIdentificadores.get(i);
        // Comprobar que existe o no simbolo en la tabla
        try
        {
          // Insercion del parametro en la tabla de simbolos
          s = tabla.introducir_parametro(identificadorActual, tipo_Var, cl_Param, nivel, dir);
          // Añadir parametro a la lista de parametros
          lista.add(s);
        }		
        catch (ParametroRepetidoException pRepExcep)
        {
          // El parametro ya esta repetido 
          pRepExcep.parametroRepetidoExcepcion(identificadorActual);
        }
      }
      // Devolucion de la lista de parametros
      return lista;
    }
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de declaracion variables OK
void declaracion_variables() :
{
  // Declaracion de variables 
  Token t;
}
{
  try
  {
    ((declaracion()) t = < tPUNTYCOM >) *
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla para los tipos de variables OK
Simbolo.Tipo_variable tipos_variables() :
{
  // Declaracion de variable
  Token t;
}
{
  try
  {
    // Asignacion del token leido
    (
    t = < tENTERO >
  | t = < tCARACTER >
  | t = < tBOOLEANO >
    )
    {
      // Control del tipo token
      switch (t.kind)
      {
        case tENTERO : 
        // Es token tENTERO
        return Simbolo.Tipo_variable.ENTERO;
        break;
        case tCARACTER : 
        // Es token tCARACTER
        return Simbolo.Tipo_variable.CHAR;
        break;
        case tCONSTCAD : 
        // Es token tCARACTER
        return Simbolo.Tipo_variable.CADENA;
        break;
        case tBOOLEANO : 
        // Es token tBOOLEANO
        return Simbolo.Tipo_variable.BOOLEANO;
        break;
        default : 
        // No es niguno de los anteriores es DESCONOCIDO
        return Simbolo.Tipo_variable.DESCONOCIDO;
      }
    }
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de declaracion OK
void declaracion() :
{
  // Declaracion de variables
  Token t;
  Simbolo.Tipo_variable tp_Var;
  LinkedList < String > lista = new LinkedList < String > ();
  // Variable para guardar el identificador del simbolo a introducir
  String identificadorActual;
  Simbolo s;
}
{
  try
  {
    tp_Var = tipos_variables() 
    lista = identificadores()
    {
      // Tamaño de la lista de identificadores
      int dimension = lista.size();
      //Bucle de recorrido de insercion de variables
      for (int i = 0; i < dimension; i++)
      {
        // Obtencion del identificador actual
        identificadorActual = lista.get(i);
        // Simbolo ya existente en la tabla de simbolos
        try
        {
          // introducir el nuevo simbolo
          tabla.introducir_variable(identificadorActual, tp_Var, nivel, dir);
        }
        catch (VariableRepetidaException vRepExcep)
        {
          // El identificador ya existe en la tabla de simbolos
          vRepExcep.variableRepetidaExcepcion(identificadorActual);
        }
      }
    }
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla para los identificadores OK
LinkedList < String > identificadores() :
{
  // Declaracion de una lista auxiliar de identificadores
  Token t;
  // Lista de identificadores (parametros o variables)
  LinkedList < String > listaIdentificadores = new LinkedList < String > ();
}
{
  try
  {
    // Coger primer identificador
    t = < tIDENTIFICADOR >
    {
      // Añadir el identificador a lista
      listaIdentificadores.add(t.image);
    }
    (< tCOMA > 
    // Coger los siguientes identificadores
    t = < tIDENTIFICADOR >
    {
      // Añadir el identificador a lista
      listaIdentificadores.add(t.image);
    }
    ) *
    // Todos los identificadores
    {
      return listaIdentificadores;
    }
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla para las clases de parametros OK
Simbolo.Clase_parametro clase_parametros() :
{
  // Declaracion de variables
  Token t;
}
{
  try
  {
    // Asignacion del token hallado
    (
    t = < tVAL >
  | t = < tREF >
    )
    {
      if (t.kind == tVAL)
      {
        // Es token tVAL
        return Simbolo.Clase_parametro.VAL;
      }
      else if (t.kind == tREF)
      {
        // Es tokeb tREF
        return Simbolo.Clase_parametro.REF;
      }
      else
      {
        // Clase de parametro erroneo
        System.out.println("La clase de parametro no es correcta");
      }
      // El tipo de clase ha sido procesada
    }
  }
  catch (ParseException e)
  {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}
