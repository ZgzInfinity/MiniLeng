/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */

options
{
  static = true;
  ignore_case = true;
}

PARSER_BEGIN(Compilador)

package Foo;
import Foo.Tabla_Simbolos;
import Foo.Simbolo.Tipo_simbolo;
import Foo.Simbolo.Tipo_variable;
import Foo.Simbolo.Clase_parametro;
import Foo.SimboloNoEncontradoException;

import java.io.File;
import java.io.IOException;
import java.util.LinkedList;

public class Compilador
{

  // IniCio del nivel de declaraciones anidadas
  public static int nivel = 0;

  // Variable de direccion por defecto a 0
  public static long dir = 0;

  
  public static Tabla_Simbolos tabla = new Tabla_Simbolos();


  public static void main(String args []) throws ParseException
  {
    /* nombre del fichero */
	String nombreArchivo;
	String path = "C:\\Users\\Gord\\Desktop\\programas\\";

	if (args[0].equals("-v")) {
	  	System.out.println("Compilacion en modo verbose");
	  	nombreArchivo = args[1];
	}
	else {
	    System.out.println("Compilacion sin modo verbose");
	    nombreArchivo = args[0];
    }

	/* Completar la ruta del path */
	path += nombreArchivo;


    System.out.println("LEYENDO FICHERO " + nombreArchivo + "\n");
    try
    {
	      /* Crear el parser con respecto al fichero */
	      Compilador parser = new Compilador (new java.io.FileInputStream(path));
	      
	      // Inicializacion de la tabla de simbolos
		  tabla.inicializar_tabla();
		  
	      int res = Compilador.programa();
	      if (args[0].equals("-v")) {
	
		      /* Mostrar total de tokens */
			  TablaHash.mostrarTokensNormales();
			
			  /* Mostrar total de identificadores */
			  TablaHash.mostrarIdentificadores();
		  }
		  System.out.println("El fichero introducido es correcto");
	 } 
	 catch (Exception e)
	 {
	       System.out.println("INCORRECTO");
	       System.out.println(e.getMessage());
	       Compilador.ReInit(System.in);
	 }
	 catch (Error e)
	 {
	       // Obtencion del error sintactico 
	       int fila = CompiladorTokenManager.input_stream.getBeginLine();
	       int columna = CompiladorTokenManager.input_stream.getBeginColumn();
	       String tokenMalo = CompiladorTokenManager.input_stream.GetImage();
	
	       ErrorLexico eL = new ErrorLexico(fila, columna, tokenMalo); 
	 }
  }
}

PARSER_END(Compilador)

SKIP : /* CARACTERES A IGNORAR */
{
  " "
| "\r"
| "\t"
| "\n"
| "%%" : ComentLinea
}

<ComentLinea> SKIP :
{
  "%%" : DEFAULT
}

<ComentLinea> MORE :
{
  <~[]>
}

SPECIAL_TOKEN : /* Comentario de una linea */
{
  <SINGLE_LINE_COMMENT: "%" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

TOKEN : /* OPERADORES ARITMETICOS */
{
  < tPLUS : "+" >
  {
    TablaHash.anyadirHashTokens("tPLUS");
  }
| < tMINUS : "-" >
  {
    TablaHash.anyadirHashTokens("tMINUS");
  }
| < tMULTIPLY : "*" >
  {
    TablaHash.anyadirHashTokens("tMULTIPLY");
  }
| < tDIVIDE : "/" >
  {
    TablaHash.anyadirHashTokens("tDIVIDE");
  }
| < tMAYOR : ">" >
  {
    TablaHash.anyadirHashTokens("tMAYOR");
  }
| < tMENOR : "<" >
  {
    TablaHash.anyadirHashTokens("tMENOR");
  }
| < tIGUAL : "=" >
  {
    TablaHash.anyadirHashTokens("tIGUAL");
  }
| < tMAI : ">=" >
  {
    TablaHash.anyadirHashTokens("tMAI");
  }
| < tMEI : "<=" >
  {
    TablaHash.anyadirHashTokens("tMEI");
  }
| < tNI : "<>" >
  {
    TablaHash.anyadirHashTokens("tNI");
  }
| < tOPAS : ":=" >
  {
    TablaHash.anyadirHashTokens("tOPAS");
  }
}

TOKEN : /* OPERADORES LOGICOS */
{
  < tAND : "and" >
   {
    TablaHash.anyadirHashTokens("tAND");
   }
| < tOR : "or" >
  {
    TablaHash.anyadirHashTokens("tOR");
  }
| < tNOT : "not" >
  {
    TablaHash.anyadirHashTokens("tNOT");
  }
}


TOKEN : /* PALABRAS RESERVADAS */
{
  < tPROGRAMA : "programa" >
   {
    TablaHash.anyadirHashTokens("tPROGRAMA");
   }
| < tVAR : "var" >
  {
    TablaHash.anyadirHashTokens("tVAR");
  }
| < tPRINCIPIO : "principio" >
  {
    TablaHash.anyadirHashTokens("tPRINCIPIO");
  }
| < tFIN : "fin" >
  {
    TablaHash.anyadirHashTokens("tFIN");
  }
| < tSI : "si" >
  {
    TablaHash.anyadirHashTokens("tSI");
  }
| < tENT : "ent" >
  {
    TablaHash.anyadirHashTokens("tENT");
  }
| < tSI_NO : "si_no" >
  {
    TablaHash.anyadirHashTokens("tSI_NO");
  }
| < tFSI : "fsi" >
  {
    TablaHash.anyadirHashTokens("tFSI");
  }
| < tMQ : "mq" >
  {
    TablaHash.anyadirHashTokens("tMQ");
  }
| < tFMQ : "fmq" >
  {
    TablaHash.anyadirHashTokens("tFMQ");
  }
| < tESCRIBIR : "escribir" >
  {
    TablaHash.anyadirHashTokens("tESCRIBIR");
  }
| < tLEER : "leer" >
  {
    TablaHash.anyadirHashTokens("tLEER");
  }
| < tMOD : "mod" >
  {
    TablaHash.anyadirHashTokens("tMOD");
  }
| < tDIV : "div" >
  {
    TablaHash.anyadirHashTokens("tDIV");
  }
| < tENTERO : "entero" >
  {
    TablaHash.anyadirHashTokens("tENTERO");
  }
| < tBOOLEANO : "booleano" >
  {
    TablaHash.anyadirHashTokens("tBOOLEANO");
  }
| < tCARACTER : "caracter" >
  {
    TablaHash.anyadirHashTokens("tCARACTER");
  }
| < tTRUE : "true" >
  {
    TablaHash.anyadirHashTokens("tTRUE");
  }
| < tFALSE : "false" >
  {
    TablaHash.anyadirHashTokens("tFALSE");

  }
| < tENTACAR : "entacar" >
  {
    TablaHash.anyadirHashTokens("tENTACAR");  
  }
| < tCARAENT : "caraent" >
  {
    TablaHash.anyadirHashTokens("tCARAENT");
  }
| < tACCION : "accion" >
  {
    TablaHash.anyadirHashTokens("tACCION");
  }
| < tVAL : "val" >
  {
    TablaHash.anyadirHashTokens("tVAL");

  }
| < tREF : "ref" >
  {
    TablaHash.anyadirHashTokens("tREF");
  }
}


TOKEN :  /*EXPRESIONES */
{
  < #tDIGITO : ["0"-"9"] >	
| < #tLETRA : ["a"-"z"] >
| < tCONSTCHAR : ("\"")(~["\""])("\"") >
  {
    TablaHash.anyadirHashTokens("tCONSTCHAR");
  }
| < tCONSTCAD :  ("\"")(~["\""])+("\"") >
  {
    TablaHash.anyadirHashTokens("tCONSTCAD");
  }
| < tCONSTANTE_NUMERICA : (< tDIGITO >)+ >
  {
    TablaHash.anyadirHashTokens("tCONSTANTE_NUMERICA");
  }
| < tIDENTIFICADOR  : (< tLETRA > | ((< tLETRA > | "_")(< tLETRA > | "_" | < tDIGITO >)*(< tLETRA > | < tDIGITO >))) >
	{
	  TablaHash.anyadirHashTokens(image.toString());
	  TablaHash.anyadirHashIdentificadores(image.toString());
	}
}


TOKEN : /* OPERADORES SEPARADDORES */
{
  < tPUNTYCOM : ";" >
  {
    TablaHash.anyadirHashTokens("tPUNTYCOM");
  }
| < tCOMA : "," >
  {
    TablaHash.anyadirHashTokens("tCOMA");
  }
| < tPARENTESIS_IZDA : "(" >
  {
    TablaHash.anyadirHashTokens("tPARENTESIS_IZDA");
  }
| < tPARENTESIS_DCHA : ")" >
  {
    TablaHash.anyadirHashTokens("tPARENTESIS_DCHA");
  }
}


/* Construccion del analizador sintactico */

// Regla de programa
int programa():
{
  Token tSim, t;
  Simbolo s;
  Simbolo.Tipo_simbolo tp_Sim;
}
{
  try{
       // Lectura del token programa
      < tPROGRAMA >
       // Guardado del nombre del programa
       t = < tIDENTIFICADOR >
       {
         
         // Insertar en la tabla de simbolos el token del programa
         // no se comprueba porque es el primero

         s = tabla.introducir_programa(t.image, dir);
       }
       // Lectura del resto de datos
       < tPUNTYCOM > declaracion_variables() declaracion_acciones() bloque_sentencias() < EOF >
       {
         return 0;
       }
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
     return 1;
  }
}


// Regla de bloque_sentencias OK
void bloque_sentencias():
{
  // Declaracion de variables
  Token t;
}
{
  try {
       < tPRINCIPIO > lista_sentencias() t = < tFIN >
       {
         // Ocultar los parametros del nivel actual
         tabla.ocultar_parametros(nivel);
         
         // Detectado el fin de un bloque de sentencias
         // Mostrar el contenido de la tabla Hash
         tabla.mostrarTabla_Simbolos();
       }
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de lista_sentencias OK EN DUDA
void lista_sentencias():
{
}
{
  try{
      (sentencia())*
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla de sentencia OK
void sentencia():
{
}
{
 try{
      leer() < tPUNTYCOM >
   	| escribir() < tPUNTYCOM >
   	| asig_invoc()
   	| seleccion()
   	| mientras_que()
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}


void asig_invoc():
{
}
{
try {
       < tIDENTIFICADOR > (asignacion() | invocacion_accion())
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla de asignacion OK
void asignacion():
{
}
{
  try {
       < tOPAS > expresion() < tPUNTYCOM >
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla de lista_asignables OK
void lista_asignables():
{
}
{
  try {
      identificadores()
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// Regla de leer OK
void leer():
{
}
{
  try {
       < tLEER >< tPARENTESIS_IZDA > lista_asignables() < tPARENTESIS_DCHA >
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}



// Regla de escribir OK
void escribir():
{
}
{
  try {
       < tESCRIBIR >< tPARENTESIS_IZDA > lista_escribibles() < tPARENTESIS_DCHA >
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla de lista_escribibles OK
void lista_escribibles():
{
}
{
  try {
       escribible() ( < tCOMA > escribible() )*
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla de lista_escribibles OK
void escribible():
{
}
{
  try {
      < tCONSTCHAR >
     | < tCONSTCAD >
     | < tENTACAR > <tPARENTESIS_IZDA > <tCONSTANTE_NUMERICA > <tPARENTESIS_DCHA >
     | < tIDENTIFICADOR >
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}



// Regla de invocacion accion OK
void invocacion_accion():
{
}
{
  try {
     (argumentos())? < tPUNTYCOM >
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}



//Regla de mientras que OK
void mientras_que():
{
}
{
  try {
     < tMQ > expresion() lista_sentencias() < tFMQ >
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla para los argumentos OK
void argumentos():
{
}
{
  try {
      < tPARENTESIS_IZDA > (lista_expresiones())? < tPARENTESIS_DCHA >
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
  
}



// Regla de lista de expresiones
void lista_expresiones():
{
}
{
  try {
     expresion()(< tCOMA > expresion())*
  }
  catch (ParseException e) {
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla de expresion OK
void expresion():
{
}
{
 try {
  	  expresion_simple() (operador_relacional() expresion_simple())*
  }
  catch (ParseException e) {
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla de operador_relacional OK
void operador_relacional():
{
}
{
  try {
      < tIGUAL >
    | < tMENOR >
    | < tMEI >
    | < tNI >
    | < tMAI >
    | < tMAYOR >
  }
  catch (ParseException e) {
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla operador aditivo OK
void operador_aditivo():
{
}
{
  try {
      < tPLUS > 
	| < tMINUS >
	| < tOR >
  }
  catch (ParseException e) {
	 ErrorSintactico eS = new ErrorSintactico(e);
  }
}

// regla de expresion simple OK
void expresion_simple():
{
}
{
  try {
       (< tPLUS > )? termino() (operador_aditivo() termino())*
  }
  catch (ParseException e) {
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}
 

// Regla de termino OK
void termino():
{
}
{
  try {
     factor() (operador_multiplicativo() factor())*
  }
  catch (ParseException e) {
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}



// Regla de operador multiplicativo OK
void operador_multiplicativo():
{
}
{
  try { 
 	  < tMULTIPLY >
 	| < tDIVIDE >
 	| < tDIV >
 	| < tMOD >
 	| < tAND >
  }
  catch(ParseException e) {
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}



// Regla de factor OK
void factor():
{
}
{
  try {
      < tMINUS > factor()
	| < tNOT > factor()
	| < tPARENTESIS_IZDA > expresion() < tPARENTESIS_DCHA >
	| < tENTACAR >< tPARENTESIS_IZDA > expresion() < tPARENTESIS_DCHA >
	| < tCARAENT >< tPARENTESIS_IZDA > expresion() < tPARENTESIS_DCHA >
	| < tIDENTIFICADOR >
	| < tCONSTANTE_NUMERICA >
	| < tCONSTCHAR >
	| < tCONSTCAD >
	| < tTRUE >
	| < tFALSE >
  }
  catch (ParseException e) {
	 ErrorSintactico eS = new ErrorSintactico(e);
  }
}



// Regla de seelccion OK
void seleccion():
{
}
{
  try {
    < tSI > expresion() < tENT > lista_sentencias() (< tSI_NO > lista_sentencias())? < tFSI >
  }
  catch (ParseException e) {
  	 ErrorSintactico eS = new ErrorSintactico(e);
  }
}



// Regla de declaracion_acciones OK
void declaracion_acciones():
{
}
{
  try { 
 	(declaracion_accion())*
  }
  catch(ParseException e) {
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla de declaracion_Accion OK
void declaracion_accion():
{
}
{
  try { 
 	   cabecera_accion() < tPUNTYCOM > declaracion_variables() declaracion_acciones() bloque_sentencias()
 	   {
 	   // Eliminacion de variables
       tabla.eliminar_variables(nivel);

	   // Eliminar las acciones
       tabla.eliminar_acciones(nivel);

	   // Eliminar los parametros ocultos
       tabla.eliminar_parametros_ocultos(nivel + 1);
       
       // Decrementar el nivel porque se cierra un bloque       
       nivel--;        
 	  }
  }
  catch(ParseException e) {
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla de cabecera_accion OK
void cabecera_accion():
{
  Token tSim, tId;
  Simbolo s = null;
  Simbolo.Tipo_simbolo tp_Sim;
  boolean ok = false;

  // Lista de parametros de la accion
  LinkedList<LinkedList<Simbolo>> listaDeParametros = new LinkedList<LinkedList<Simbolo>>();
}
{
  try {
     // Apilar la nueva definicion de accion si no existe   
 	 tSim = < tACCION >
 	 tId = < tIDENTIFICADOR >
 	 {
 	     // Insertar en la tabla de simbolos el nuevo identificador
		 try { 
 	  	     s = tabla.introducir_accion(tId.image, nivel, dir);
 	  	     ok = true;	     
 	 	 }
 	 	 catch(AccionRepetidaException aRepExcep) {
 	 		 // El simbolo ya existe en la tabla de simbolos
 	 		 aRepExcep.accionRepetidaExcepcion(tId.image);
 	     }

 	     // Incrementar el nivel actual
 	     nivel++;
 	  }
 	 // Procesamiento de los parametros
 	 listaDeParametros = parametros_formales()
 	 {
 	   // Se ha efectuado con exito
 	   if (ok) { 
	 	   for (int i = 0; i < listaDeParametros.size(); i++) { 
		   	 	// Añadir la lista de parametros al simbolo
	 	   		s.anyadirParametrosAccion(listaDeParametros.get(i));
	 	   }
	 	   // Simbolo accion con todos los parametros
	 	   System.out.println(s.toString());
	   }
     }
  }
  catch(ParseException e) {
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla de parametros formales OK
LinkedList<LinkedList<Simbolo>> parametros_formales():
{
  // Lista global de listas de identificadores
  LinkedList<LinkedList<Simbolo>> parametros = new LinkedList<LinkedList<Simbolo>>();
}
{
  try { 
 	 (parametros = lista_parametros()
 	 {
 	   // Guardado de la lista de parametros procesada
 	   tabla.asignarListaParametros(parametros);
     }
     )?
     // Devolucion de todas las listas procesadas
     {
       return tabla.getListasParametros();
     }
  }
  catch(ParseException e) {
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}




// Regla para lista_parametros OK
LinkedList<LinkedList<Simbolo>> lista_parametros():
{
  // Lista global de listas de identificadores
  LinkedList<LinkedList<Simbolo>> listaGlobal = new LinkedList<LinkedList<Simbolo>>();

  // Lista de identificadores
  LinkedList<Simbolo> lista = new LinkedList<Simbolo>();
}
{
  try {
        < tPARENTESIS_IZDA > lista = parametros() 
		{
		  // Vaciar lista de identificadores de parametros para evitar su resinsercion
		  listaGlobal.add(lista);		  
		}
     	(< tPUNTYCOM  > lista = parametros()
     	{
     	  listaGlobal.add(lista);
		}
     	)* < tPARENTESIS_DCHA >
     	{
     	  return listaGlobal;
        }
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla de parametros OK
LinkedList<Simbolo> parametros():
{
  // Declaracion de variables

  // Simbolo a guardar en la tabla de simbolos
  Simbolo s;

  // Clase de parametro y tipo de variable del simbolo a introducir
  Simbolo.Clase_parametro cl_Param;
  Simbolo.Tipo_variable tipo_Var;

  // Lista de simbolos leidos a almacenar en la tabla de simbolos
  LinkedList<Simbolo> lista = new LinkedList<Simbolo>();

  // Lista de identificadores procesados
  LinkedList<String> listaIdentificadores = new LinkedList<String>();
}
{
  try {
         
      // Lectura del tipo de clase y del tipo de parametro
      cl_Param = clase_parametros()
      tipo_Var = tipos_variables()
      listaIdentificadores = identificadores()
     {
       // Tamaño de la lista de identificadores
       int dimension = listaIdentificadores.size();

	   // Identificador del simbolo a procesar
	   String identificadorActual;
	   
       // Bucle de recorrido de la lista de identificadores
       for (int i = 0; i < dimension; i++) {
         	// Obtener identificador actual
         	
         	identificadorActual = listaIdentificadores.get(i);
         	
			// Comprobar que existe o no simbolo en la tabla
 	      	try {
			  	// Insercion del parametro en la tabla de simbolos
				 s = tabla.introducir_parametro(identificadorActual, tipo_Var, cl_Param, nivel, dir);

				 // Añadir parametro a la lista de parametros
				 lista.add(s);
			}		
			catch (ParametroRepetidoException pRepExcep) {
			 	// El parametro ya esta repetido 
				pRepExcep.parametroRepetidoExcepcion(identificadorActual);
			}
 	   }
 	   // Devolucion de la lista de parametros
 	   return lista;
     }
  }
  catch (ParseException e){
    ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla de declaracion variables OK
void declaracion_variables():
{
  // Declaracion de variables 
  Token t;
}
{
  try {
     ((declaracion()) t = < tPUNTYCOM >)*
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla para los tipos de variables OK
Simbolo.Tipo_variable tipos_variables():
{
  // Declaracion de variable
  Token t;
}
{
  try {
      // Asignacion del token leido
       (         t = < tENTERO > | t = < tCARACTER > | t = < tBOOLEANO >
       )
      { 
       // Control del tipo token
       switch (t.kind) {
         case tENTERO:
         	// Es token tENTERO
         	return Simbolo.Tipo_variable.ENTERO;
         	break;
         case tCARACTER:
         	// Es token tCARACTER
         	return Simbolo.Tipo_variable.CHAR;
         	break;
         case tCONSTCAD:
         	// Es token tCARACTER
         	return Simbolo.Tipo_variable.CADENA;
         	break;
         case tBOOLEANO:
         	// Es token tBOOLEANO
         	return Simbolo.Tipo_variable.BOOLEANO;
         	break;
         default:
         	// No es niguno de los anteriores es DESCONOCIDO
         	return Simbolo.Tipo_variable.DESCONOCIDO;
       }
    }
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}




// Regla de declaracion OK
void declaracion():
{
  // Declaracion de variables
  Token t;
  Simbolo.Tipo_variable tp_Var;
  LinkedList<String> lista = new LinkedList<String>();

  // Variable para guardar el identificador del simbolo a introducir
  String identificadorActual;

  Simbolo s;
}
{
  try {
      tp_Var = tipos_variables()
      lista = identificadores()
     {
  
	   // Tamaño de la lista de identificadores
	   int dimension = lista.size();

 	   //Bucle de recorrido de insercion de variables
 	   for (int i = 0; i < dimension; i++) {
 	        // Obtencion del identificador actual
			identificadorActual = lista.get(i);
	            
	        // Simbolo ya existente en la tabla de simbolos
		    try {
			     // introducir el nuevo simbolo
			     tabla.introducir_variable(identificadorActual, tp_Var, nivel, dir);
		    }
		    catch (VariableRepetidaException vRepExcep) {
		         // El identificador ya existe en la tabla de simbolos
		         vRepExcep.variableRepetidaExcepcion(identificadorActual);
		    }
 	    }
     }
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}


// Regla para los identificadores OK
LinkedList<String> identificadores():
{
  // Declaracion de una lista auxiliar de identificadores
  Token t;

  // Lista de identificadores (parametros o variables)
  LinkedList<String> listaIdentificadores = new LinkedList<String>();
}
{
  try {
     // Coger primer identificador
     t = < tIDENTIFICADOR >
     {
       // Añadir el identificador a lista
       	 listaIdentificadores.add(t.image);
     }
     (< tCOMA >
      // Coger los siguientes identificadores
      t = < tIDENTIFICADOR >
	  {
       	 // Añadir el identificador a lista
       	 listaIdentificadores.add(t.image);
      }
     )*
     // Todos los identificadores
     { 
     	return listaIdentificadores;
     }
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}




// Regla para las clases de parametros OK
Simbolo.Clase_parametro clase_parametros():
{
  // Declaracion de variables
  Token t;
}
{
  try {
    // Asignacion del token hallado
    (      t = < tVAL > | t = < tREF >
    )
    {
      if (t.kind == tVAL) {
        // Es token tVAL
        return Simbolo.Clase_parametro.VAL;
      }
      else if (t.kind == tREF) {
        // Es tokeb tREF
        return Simbolo.Clase_parametro.REF;
      }
      else {
        // Clase de parametro erroneo
        System.out.println("La clase de parametro no es correcta");
      }
	  // El tipo de clase ha sido procesada
    }
  }
  catch (ParseException e){
     ErrorSintactico eS = new ErrorSintactico(e);
  }
}











